/*
# [Full System Setup]
This script sets up the entire database schema for the Multi Talk application, including the affiliate system, Kanban board, blog, and contact management. It is designed to be idempotent, meaning it can be run multiple times without causing errors. It checks for the existence of each object (type, table, function, policy) before creating it.

## Query Description: [This script builds the core data structure for the application. It creates tables for user profiles, leads, blog content, and contacts. It also implements a role-based security system to control access to data, ensuring that affiliates can only see their own leads and only superadmins can manage blog posts. This is a foundational script for all application features.]

## Metadata:
- Schema-Category: ["Structural", "Safe"]
- Impact-Level: ["Low"]
- Requires-Backup: [false]
- Reversible: [true]

## Structure Details:
- Tables created: profiles, leads, authors, categories, posts, contacts
- Types created: user_role, kanban_status, post_status
- Functions created: public_handle_new_user
- Triggers created: on_auth_user_created

## Security Implications:
- RLS Status: [Enabled] on all tables.
- Policy Changes: [Yes]. Policies are created to enforce access control based on user roles (superadmin, affiliate).
- Auth Requirements: [Yes]. Policies rely on `auth.uid()` to identify the current user.

## Performance Impact:
- Indexes: [Added] Primary keys and foreign keys are indexed by default.
- Triggers: [Added] A trigger is added to the `auth.users` table to automate profile creation.
- Estimated Impact: [Low] The impact is minimal as this is primarily a structural setup.
*/

-- ========= 1. CREATE CUSTOM TYPES (IF THEY DON'T EXIST) =========
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role') THEN
    CREATE TYPE public.user_role AS ENUM ('superadmin', 'affiliate');
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'kanban_status') THEN
    CREATE TYPE public.kanban_status AS ENUM ('Nova Lead', 'Em Atendimento', 'ReuniÃ£o', 'Ganho', 'Perca');
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'post_status') THEN
    CREATE TYPE public.post_status AS ENUM ('draft', 'published', 'archived');
  END IF;
END$$;

-- ========= 2. CREATE TABLES (IF THEY DON'T EXIST) =========

-- Profiles Table (for affiliates and admins)
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL UNIQUE,
  username text UNIQUE,
  full_name text,
  avatar_url text,
  role public.user_role DEFAULT 'affiliate'::public.user_role,
  updated_at timestamp with time zone DEFAULT now(),
  PRIMARY KEY (id),
  CONSTRAINT profiles_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE
);
COMMENT ON TABLE public.profiles IS 'Stores user profile data, including their role for access control.';

-- Leads Table (for Kanban)
CREATE TABLE IF NOT EXISTS public.leads (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  name text NOT NULL,
  email text NOT NULL,
  company text,
  message text NOT NULL,
  status public.kanban_status DEFAULT 'Nova Lead'::public.kanban_status NOT NULL,
  profile_id uuid NOT NULL,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now(),
  PRIMARY KEY (id),
  CONSTRAINT leads_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE
);
COMMENT ON TABLE public.leads IS 'Stores leads generated by affiliates for the Kanban board.';

-- Authors Table (for Blog)
CREATE TABLE IF NOT EXISTS public.authors (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  user_id uuid UNIQUE,
  name text NOT NULL UNIQUE,
  bio text,
  avatar_url text,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now(),
  PRIMARY KEY (id),
  CONSTRAINT authors_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE SET NULL
);
COMMENT ON TABLE public.authors IS 'Stores author information for blog posts.';

-- Categories Table (for Blog)
CREATE TABLE IF NOT EXISTS public.categories (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  name text NOT NULL UNIQUE,
  slug text NOT NULL UNIQUE,
  description text,
  color text DEFAULT '#6366f1'::text,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now(),
  PRIMARY KEY (id)
);
COMMENT ON TABLE public.categories IS 'Stores blog post categories.';

-- Posts Table (for Blog)
CREATE TABLE IF NOT EXISTS public.posts (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  title text NOT NULL,
  slug text NOT NULL UNIQUE,
  excerpt text,
  content text,
  featured_image text,
  meta_title text,
  meta_description text,
  meta_keywords text,
  author_id uuid,
  category_id uuid,
  status public.post_status DEFAULT 'draft'::public.post_status,
  featured boolean DEFAULT false,
  read_time integer,
  views integer DEFAULT 0,
  published_at timestamp with time zone,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now(),
  PRIMARY KEY (id),
  CONSTRAINT posts_author_id_fkey FOREIGN KEY (author_id) REFERENCES public.authors(id) ON DELETE SET NULL,
  CONSTRAINT posts_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.categories(id) ON DELETE SET NULL
);
COMMENT ON TABLE public.posts IS 'Stores blog post content and metadata.';

-- Contacts Table (for general contact form)
CREATE TABLE IF NOT EXISTS public.contacts (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  name text NOT NULL,
  email text NOT NULL,
  company text,
  message text NOT NULL,
  created_at timestamp with time zone DEFAULT now(),
  PRIMARY KEY (id)
);
COMMENT ON TABLE public.contacts IS 'Stores messages from the main contact form.';


-- ========= 3. CREATE FUNCTIONS & TRIGGERS FOR AUTOMATION =========

-- Function to create a profile for a new user
CREATE OR REPLACE FUNCTION public.public_handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (user_id, full_name, username, avatar_url)
  VALUES (
    new.id, 
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'user_name',
    new.raw_user_meta_data->>'avatar_url'
  );
  return new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to call the function on new user creation
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.public_handle_new_user();


-- ========= 4. ENABLE RLS AND CREATE POLICIES =========

-- Profiles
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- Leads
ALTER TABLE public.leads ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Affiliates can view their own leads." ON public.leads;
CREATE POLICY "Affiliates can view their own leads." ON public.leads FOR SELECT USING (auth.uid() = (SELECT user_id FROM public.profiles WHERE id = profile_id));
DROP POLICY IF EXISTS "Affiliates can update their own leads." ON public.leads;
CREATE POLICY "Affiliates can update their own leads." ON public.leads FOR UPDATE USING (auth.uid() = (SELECT user_id FROM public.profiles WHERE id = profile_id)) WITH CHECK (auth.uid() = (SELECT user_id FROM public.profiles WHERE id = profile_id));
DROP POLICY IF EXISTS "Leads can be inserted publicly." ON public.leads;
CREATE POLICY "Leads can be inserted publicly." ON public.leads FOR INSERT WITH CHECK (true);

-- Authors
ALTER TABLE public.authors ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Authors are public." ON public.authors;
CREATE POLICY "Authors are public." ON public.authors FOR SELECT USING (true);

-- Categories
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Categories are public." ON public.categories;
CREATE POLICY "Categories are public." ON public.categories FOR SELECT USING (true);

-- Posts
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Published posts are public." ON public.posts;
CREATE POLICY "Published posts are public." ON public.posts FOR SELECT USING (status = 'published'::post_status);
DROP POLICY IF EXISTS "Admins can view all posts." ON public.posts;
CREATE POLICY "Admins can view all posts." ON public.posts FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE user_id = auth.uid()));
DROP POLICY IF EXISTS "Superadmins can manage all posts." ON public.posts;
CREATE POLICY "Superadmins can manage all posts." ON public.posts FOR ALL USING ((SELECT role FROM public.profiles WHERE user_id = auth.uid()) = 'superadmin'::user_role) WITH CHECK ((SELECT role FROM public.profiles WHERE user_id = auth.uid()) = 'superadmin'::user_role);

-- Contacts
ALTER TABLE public.contacts ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Contacts can be inserted publicly." ON public.contacts;
CREATE POLICY "Contacts can be inserted publicly." ON public.contacts FOR INSERT WITH CHECK (true);
DROP POLICY IF EXISTS "Superadmins can view contacts." ON public.contacts;
CREATE POLICY "Superadmins can view contacts." ON public.contacts FOR SELECT USING ((SELECT role FROM public.profiles WHERE user_id = auth.uid()) = 'superadmin'::user_role);
