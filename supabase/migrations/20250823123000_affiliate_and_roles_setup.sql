/*
# [Feature] Affiliate & Superadmin System Setup
This script sets up the database structure for an affiliate system, a lead management Kanban board, and a role-based access control system (superadmin/affiliate).

## Query Description:
This is a structural migration. It adds new tables, types, and security policies. It is safe to run on a new setup. If you have existing user data, this script will attempt to create profiles for them but will not delete any existing users from the `auth.users` table.

## Metadata:
- Schema-Category: "Structural"
- Impact-Level: "Medium"
- Requires-Backup: true
- Reversible: false

## Structure Details:
- **Types Created:** `user_role`, `kanban_status`
- **Tables Created:** `profiles`, `leads`
- **Triggers Created:** `on_auth_user_created` to automatically create a user profile.
- **RLS Policies:**
  - `profiles`: Users can only see and edit their own profile.
  - `leads`: Affiliates can only see and manage their own leads.
  - `posts`: Only superadmins can create, update, or delete posts. All authenticated users can read.

## Security Implications:
- RLS Status: Enabled on `profiles`, `leads`, and `posts`.
- Policy Changes: Yes, this script enforces strict access control.
- Auth Requirements: All operations require an authenticated user.

## Performance Impact:
- Indexes: Primary keys and foreign keys are indexed by default.
- Triggers: One trigger is added on user creation.
- Estimated Impact: Low performance impact on existing operations.
*/

-- Step 1: Create custom ENUM types first to avoid dependency errors.
-- This ensures the types exist before tables try to use them.

create type public.user_role as enum ('superadmin', 'affiliate');
create type public.kanban_status as enum ('Nova Lead', 'Em Atendimento', 'ReuniÃ£o', 'Ganho', 'Perca');


-- Step 2: Create the user profiles table.
-- This table will store public user data and their role.

create table public.profiles (
  id uuid references auth.users on delete cascade not null primary key,
  updated_at timestamp with time zone,
  username text unique,
  full_name text,
  avatar_url text,
  role public.user_role not null default 'affiliate'
);

alter table public.profiles enable row level security;

create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );

create policy "Users can insert their own profile."
  on profiles for insert
  with check ( auth.uid() = id );

create policy "Users can update their own profile."
  on profiles for update
  using ( auth.uid() = id );

-- Step 3: Create the leads table for the Kanban board.
-- This table stores leads generated by affiliates.

create table public.leads (
  id uuid default gen_random_uuid() primary key,
  profile_id uuid not null references public.profiles(id) on delete cascade,
  name text not null,
  email text not null,
  company text,
  message text not null,
  status public.kanban_status not null default 'Nova Lead',
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now()
);

alter table public.leads enable row level security;

create policy "Affiliates can view their own leads."
  on public.leads for select
  using ( auth.uid() = profile_id );

create policy "Affiliates can insert new leads for themselves."
  on public.leads for insert
  with check ( auth.uid() = profile_id );

create policy "Affiliates can update their own leads."
  on public.leads for update
  using ( auth.uid() = profile_id );

-- Step 4: Create a trigger to automatically create a profile for new users.

create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, username, full_name, avatar_url)
  values (
    new.id,
    new.raw_user_meta_data->>'user_name',
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'avatar_url'
  );
  return new;
end;
$$;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


-- Step 5: Update RLS policies on the posts table for superadmin control.

alter table public.posts enable row level security;

-- Drop existing policies if they exist to avoid conflicts
drop policy if exists "Enable read access for all users" on public.posts;
drop policy if exists "Allow all access to authenticated users" on public.posts;


-- Allow any authenticated user to read posts.
create policy "Enable read access for all authenticated users"
  on public.posts for select
  using ( auth.role() = 'authenticated' );

-- Allow only users with the 'superadmin' role to insert, update, or delete posts.
create policy "Allow superadmins to manage posts"
  on public.posts for all
  using ( (select role from public.profiles where id = auth.uid()) = 'superadmin' )
  with check ( (select role from public.profiles where id = auth.uid()) = 'superadmin' );
