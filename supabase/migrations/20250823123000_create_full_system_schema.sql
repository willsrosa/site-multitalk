/*
# [Full System Schema Creation]
This script creates the entire database schema for the Multi Talk application, including tables for the blog, affiliate system, and Kanban. It is designed to be idempotent, meaning it can be run multiple times without causing errors. It checks for the existence of types, tables, and policies before creating them.

## Query Description: [This operation will create and configure all necessary tables for the application. It is safe to run on an existing database as it uses 'IF NOT EXISTS' checks. No data will be lost.]

## Metadata:
- Schema-Category: ["Structural"]
- Impact-Level: ["Low"]
- Requires-Backup: [false]
- Reversible: [false]

## Structure Details:
- **Types Created:** user_role, kanban_status
- **Tables Created:** authors, categories, posts, contacts, profiles, leads
- **Functions Created:** handle_new_user, get_user_role
- **Triggers Created:** on_auth_user_created
- **RLS Policies:** Enabled and configured for all tables.

## Security Implications:
- RLS Status: [Enabled]
- Policy Changes: [Yes]
- Auth Requirements: [Requires user authentication for most operations. Implements a 'superadmin' role for post management.]

## Performance Impact:
- Indexes: [Primary keys and foreign keys are indexed by default.]
- Triggers: [Adds a trigger on user creation, which has minimal performance impact.]
- Estimated Impact: [Low. The operations are efficient and run only if needed.]
*/

-- 1. Create Custom Types IF NOT EXISTS
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role') THEN
    CREATE TYPE public.user_role AS ENUM ('superadmin', 'affiliate');
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'kanban_status') THEN
    CREATE TYPE public.kanban_status AS ENUM ('Nova Lead', 'Em Atendimento', 'ReuniÃ£o', 'Ganho', 'Perca');
  END IF;
END$$;


-- 2. Create Tables IF NOT EXISTS

-- Table for Authors
CREATE TABLE IF NOT EXISTS public.authors (
  id uuid default gen_random_uuid() not null,
  user_id uuid null,
  name character varying not null,
  bio text null,
  avatar_url text null,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint authors_pkey primary key (id),
  constraint authors_name_key unique (name),
  constraint authors_user_id_fkey foreign key (user_id) references auth.users (id) on delete set null
);
ALTER TABLE public.authors ENABLE ROW LEVEL SECURITY;


-- Table for Categories
CREATE TABLE IF NOT EXISTS public.categories (
  id uuid default gen_random_uuid() not null,
  name character varying not null,
  slug character varying not null,
  description text null,
  color character varying not null default '#6366f1'::character varying,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint categories_pkey primary key (id),
  constraint categories_name_key unique (name),
  constraint categories_slug_key unique (slug)
);
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;


-- Table for Posts
CREATE TABLE IF NOT EXISTS public.posts (
  id uuid default gen_random_uuid() not null,
  title character varying not null,
  slug character varying not null,
  excerpt text not null,
  content text not null,
  featured_image text null,
  meta_title character varying null,
  meta_description text null,
  meta_keywords text null,
  author_id uuid null,
  category_id uuid null,
  status public.post_status not null default 'draft'::public.post_status,
  featured boolean not null default false,
  read_time integer not null default 5,
  views integer not null default 0,
  published_at timestamp with time zone null,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint posts_pkey primary key (id),
  constraint posts_slug_key unique (slug),
  constraint posts_author_id_fkey foreign key (author_id) references public.authors (id) on delete set null,
  constraint posts_category_id_fkey foreign key (category_id) references public.categories (id) on delete set null
);
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;


-- Table for Contacts
CREATE TABLE IF NOT EXISTS public.contacts (
  id bigint generated by default as identity,
  name character varying not null,
  email character varying not null,
  company character varying null,
  message text not null,
  created_at timestamp with time zone not null default now(),
  constraint contacts_pkey primary key (id)
);
ALTER TABLE public.contacts ENABLE ROW LEVEL SECURITY;


-- Table for Profiles (Affiliates/Users)
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid default gen_random_uuid() not null,
  user_id uuid not null,
  username text not null,
  full_name text null,
  avatar_url text null,
  role public.user_role not null default 'affiliate'::public.user_role,
  updated_at timestamp with time zone null,
  constraint profiles_pkey primary key (id),
  constraint profiles_user_id_key unique (user_id),
  constraint profiles_username_key unique (username),
  constraint profiles_user_id_fkey foreign key (user_id) references auth.users (id) on delete cascade
);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;


-- Table for Leads (Kanban)
CREATE TABLE IF NOT EXISTS public.leads (
  id uuid default gen_random_uuid() not null,
  name character varying not null,
  email character varying not null,
  company character varying null,
  message text not null,
  status public.kanban_status not null default 'Nova Lead'::public.kanban_status,
  profile_id uuid not null,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint leads_pkey primary key (id),
  constraint leads_profile_id_fkey foreign key (profile_id) references public.profiles (id) on delete cascade
);
ALTER TABLE public.leads ENABLE ROW LEVEL SECURITY;


-- 3. Create Functions and Triggers for Profile Automation

-- Function to handle new user creation
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (user_id, username, full_name, avatar_url)
  VALUES (
    new.id,
    new.raw_user_meta_data->>'user_name'::text,
    new.raw_user_meta_data->>'full_name'::text,
    new.raw_user_meta_data->>'avatar_url'::text
  );
  return new;
END;
$$;

-- Trigger to call the function on new user signup
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();


-- Function to get user role
CREATE OR REPLACE FUNCTION public.get_user_role(p_user_id uuid)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  v_role text;
BEGIN
  SELECT role::text INTO v_role
  FROM public.profiles
  WHERE user_id = p_user_id;
  
  RETURN v_role;
END;
$$;


-- 4. Create RLS Policies

-- Policies for PROFILES
DROP POLICY IF EXISTS "Allow individual read access" ON public.profiles;
CREATE POLICY "Allow individual read access" ON public.profiles FOR SELECT USING (auth.uid() = user_id);
DROP POLICY IF EXISTS "Allow individual update access" ON public.profiles;
CREATE POLICY "Allow individual update access" ON public.profiles FOR UPDATE USING (auth.uid() = user_id);

-- Policies for LEADS
DROP POLICY IF EXISTS "Allow individual access to leads" ON public.leads;
CREATE POLICY "Allow individual access to leads" ON public.leads FOR ALL USING (
  (SELECT profile_id FROM public.profiles WHERE user_id = auth.uid()) = profile_id
);

-- Policies for POSTS
DROP POLICY IF EXISTS "Allow public read access to published posts" ON public.posts;
CREATE POLICY "Allow public read access to published posts" ON public.posts FOR SELECT USING (status = 'published'::public.post_status);
DROP POLICY IF EXISTS "Allow superadmin full access to posts" ON public.posts;
CREATE POLICY "Allow superadmin full access to posts" ON public.posts FOR ALL USING (public.get_user_role(auth.uid()) = 'superadmin');

-- Policies for other tables (public read)
DROP POLICY IF EXISTS "Allow public read access" ON public.authors;
CREATE POLICY "Allow public read access" ON public.authors FOR SELECT USING (true);
DROP POLICY IF EXISTS "Allow public read access" ON public.categories;
CREATE POLICY "Allow public read access" ON public.categories FOR SELECT USING (true);

-- Policy for CONTACTS (allow any authenticated user to insert)
DROP POLICY IF EXISTS "Allow insert for authenticated users" ON public.contacts;
CREATE POLICY "Allow insert for authenticated users" ON public.contacts FOR INSERT TO authenticated WITH CHECK (true);
