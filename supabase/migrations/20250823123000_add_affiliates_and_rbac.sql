/*
  # [Feature] Affiliate System & Superadmin RBAC
  This migration sets up the database structure for an affiliate system, a lead management Kanban, and introduces role-based access control (RBAC) to restrict post management to superadmins.

  ## Query Description: 
  This operation is structural and safe for existing data in other tables. It creates new tables (`profiles`, `leads`) and functions, and updates security policies on the `posts` table. It WILL NOT delete any existing posts, authors, or categories.

  ## Metadata:
  - Schema-Category: "Structural"
  - Impact-Level: "Medium"
  - Requires-Backup: false
  - Reversible: true (by dropping the created objects)

  ## Structure Details:
  - **Tables Created:** `profiles`, `leads`
  - **Functions Created:** `handle_new_user`, `get_user_role`
  - **Triggers Created:** `on_auth_user_created` on `auth.users`
  - **Policies Updated:** RLS policies on `posts` table are modified to be role-based.
  - **Policies Created:** RLS policies for `profiles` and `leads`.

  ## Security Implications:
  - RLS Status: Enabled on `profiles`, `leads`, and `posts`.
  - Policy Changes: Yes. Post management is now restricted to the 'superadmin' role. Affiliates can only access their own data.
  - Auth Requirements: All new functionality is tied to authenticated users.

  ## Performance Impact:
  - Indexes: Primary keys and foreign keys are indexed by default.
  - Triggers: A new trigger on `auth.users` runs on user creation, which is an infrequent operation.
  - Estimated Impact: Low. The changes are optimized for common query patterns.
*/

-- STEP 1: Create the profiles table to store user data and roles.
CREATE TABLE IF NOT EXISTS public.profiles (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id uuid NOT NULL UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    username text NOT NULL UNIQUE,
    full_name text,
    avatar_url text,
    role text NOT NULL DEFAULT 'affiliate'::text,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.profiles IS 'Stores public-facing user profile information, including their role.';
-- Add a constraint to ensure the username is valid
ALTER TABLE public.profiles ADD CONSTRAINT valid_username CHECK (username ~ '^[a-z0-9-]+$');


-- STEP 2: Create the leads table for the Kanban board.
CREATE TABLE IF NOT EXISTS public.leads (
    id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
    name text NOT NULL,
    email text NOT NULL,
    company text,
    message text NOT NULL,
    status text NOT NULL DEFAULT 'Nova Lead'::text,
    profile_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.leads IS 'Stores leads generated by affiliates for the Kanban board.';


-- STEP 3: Create a function to automatically create a profile when a new user signs up.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (user_id, full_name, avatar_url, username)
  VALUES (
    new.id,
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'avatar_url',
    -- Create a unique username from email and a part of the UUID
    split_part(new.email, '@', 1) || '-' || substr(new.id::text, 1, 4)
  );
  RETURN new;
END;
$$;

-- STEP 4: Create a trigger to execute the function on new user creation.
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


-- STEP 5: Create a helper function to get a user's role.
CREATE OR REPLACE FUNCTION public.get_user_role(p_user_id uuid)
RETURNS text
LANGUAGE sql
SECURITY DEFINER
AS $$
  SELECT role FROM public.profiles WHERE user_id = p_user_id;
$$;


-- STEP 6: Set up Row Level Security (RLS) for the new tables.
-- Enable RLS on profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Users can view their own profile." ON public.profiles;
CREATE POLICY "Users can view their own profile." ON public.profiles FOR SELECT USING (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- Enable RLS on leads table
ALTER TABLE public.leads ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Affiliates can view their own leads." ON public.leads;
CREATE POLICY "Affiliates can view their own leads." ON public.leads FOR SELECT USING (profile_id = (SELECT id FROM public.profiles WHERE user_id = auth.uid()));
DROP POLICY IF EXISTS "Affiliates can create leads for themselves." ON public.leads;
CREATE POLICY "Affiliates can create leads for themselves." ON public.leads FOR INSERT WITH CHECK (profile_id = (SELECT id FROM public.profiles WHERE user_id = auth.uid()));
DROP POLICY IF EXISTS "Affiliates can update their own leads." ON public.leads;
CREATE POLICY "Affiliates can update their own leads." ON public.leads FOR UPDATE USING (profile_id = (SELECT id FROM public.profiles WHERE user_id = auth.uid()));


-- STEP 7: Update RLS policies on the posts table for superadmin control.
-- First, ensure RLS is enabled on the posts table.
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;

-- Allow public read access for published posts (no change needed here if it exists, but we ensure it)
DROP POLICY IF EXISTS "Allow public read access for published posts" ON public.posts;
CREATE POLICY "Allow public read access for published posts" ON public.posts FOR SELECT USING (status = 'published');

-- Allow superadmins to read all posts, regardless of status
DROP POLICY IF EXISTS "Allow superadmins to read all posts" ON public.posts;
CREATE POLICY "Allow superadmins to read all posts" ON public.posts FOR SELECT USING (public.get_user_role(auth.uid()) = 'superadmin');

-- Allow ONLY superadmins to create posts
DROP POLICY IF EXISTS "Allow superadmins to create posts" ON public.posts;
CREATE POLICY "Allow superadmins to create posts" ON public.posts FOR INSERT WITH CHECK (public.get_user_role(auth.uid()) = 'superadmin');

-- Allow ONLY superadmins to update posts
DROP POLICY IF EXISTS "Allow superadmins to update posts" ON public.posts;
CREATE POLICY "Allow superadmins to update posts" ON public.posts FOR UPDATE USING (public.get_user_role(auth.uid()) = 'superadmin');

-- Allow ONLY superadmins to delete posts
DROP POLICY IF EXISTS "Allow superadmins to delete posts" ON public.posts;
CREATE POLICY "Allow superadmins to delete posts" ON public.posts FOR DELETE USING (public.get_user_role(auth.uid()) = 'superadmin');

/*
  IMPORTANT: HOW TO SET A SUPERADMIN
  ----------------------------------
  After running this migration, you need to manually assign the 'superadmin' role to a user.
  1. Go to your Supabase project dashboard.
  2. Navigate to the 'Table Editor' section.
  3. Select the 'profiles' table.
  4. Find the user you want to make a superadmin.
  5. Edit the 'role' column for that user and change its value from 'affiliate' to 'superadmin'.
  6. Save the changes.
*/
